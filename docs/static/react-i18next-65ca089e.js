import{r as l}from"./react-2c2ad9dc.js";const M=(...e)=>{console?.warn&&(g(e[0])&&(e[0]=`react-i18next:: ${e[0]}`),console.warn(...e))},R={},w=(...e)=>{g(e[0])&&R[e[0]]||(g(e[0])&&(R[e[0]]=new Date),M(...e))},L=(e,t)=>()=>{if(e.isInitialized)t();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),t()};e.on("initialized",s)}},z=(e,t,s)=>{e.loadNamespaces(t,L(e,s))},F=(e,t,s,o)=>{g(s)&&(s=[s]),s.forEach(p=>{e.options.ns.indexOf(p)<0&&e.options.ns.push(p)}),e.loadLanguages(t,L(e,o))},O=(e,t,s={})=>!t.languages||!t.languages.length?(w("i18n.languages were undefined or empty",t.languages),!0):t.hasLoadedNamespace(e,{lng:s.lng,precheck:(o,p)=>{if(s.bindI18n?.indexOf("languageChanging")>-1&&o.services.backendConnector.backend&&o.isLanguageChangingTo&&!p(o.isLanguageChangingTo,e))return!1}}),g=e=>typeof e=="string",P=e=>typeof e=="object"&&e!==null,v=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,U={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"©","&#169;":"©","&reg;":"®","&#174;":"®","&hellip;":"…","&#8230;":"…","&#x2F;":"/","&#47;":"/"},$=e=>U[e],q=e=>e.replace(v,$);let S={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:q};const A=(e={})=>{S={...S,...e}},B=()=>S;let j;const W=e=>{j=e},G=()=>j,Z={type:"3rdParty",init(e){A(e.options.react),W(e)}},J=l.createContext();class K{constructor(){this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(s=>{this.usedNamespaces[s]||(this.usedNamespaces[s]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const Y=(e,t)=>{const s=l.useRef();return l.useEffect(()=>{s.current=t?s.current:e},[e,t]),s.current},k=(e,t,s,o)=>e.getFixedT(t,s,o),Q=(e,t,s,o)=>l.useCallback(k(e,t,s,o),[e,t,s,o]),_=(e,t={})=>{const{i18n:s}=t,{i18n:o,defaultNS:p}=l.useContext(J)||{},n=s||o||G();if(n&&!n.reportNamespaces&&(n.reportNamespaces=new K),!n){w("You will need to pass in an i18next instance by using initReactI18next");const i=(c,u)=>g(u)?u:P(u)&&g(u.defaultValue)?u.defaultValue:Array.isArray(c)?c[c.length-1]:c,r=[i,{},!1];return r.t=i,r.i18n={},r.ready=!1,r}n.options.react?.wait&&w("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const m={...B(),...n.options.react,...t},{useSuspense:T,keyPrefix:x}=m;let a=e||p||n.options?.defaultNS;a=g(a)?[a]:a||["translation"],n.reportNamespaces.addUsedNamespaces?.(a);const d=(n.isInitialized||n.initializedStoreOnce)&&a.every(i=>O(i,n,m)),H=Q(n,t.lng||null,m.nsMode==="fallback"?a:a[0],x),C=()=>H,b=()=>k(n,t.lng||null,m.nsMode==="fallback"?a:a[0],x),[E,N]=l.useState(C);let h=a.join();t.lng&&(h=`${t.lng}${h}`);const I=Y(h),f=l.useRef(!0);l.useEffect(()=>{const{bindI18n:i,bindI18nStore:r}=m;f.current=!0,!d&&!T&&(t.lng?F(n,t.lng,a,()=>{f.current&&N(b)}):z(n,a,()=>{f.current&&N(b)})),d&&I&&I!==h&&f.current&&N(b);const c=()=>{f.current&&N(b)};return i&&n?.on(i,c),r&&n?.store.on(r,c),()=>{f.current=!1,n&&i?.split(" ").forEach(u=>n.off(u,c)),r&&n&&r.split(" ").forEach(u=>n.store.off(u,c))}},[n,h]),l.useEffect(()=>{f.current&&d&&N(C)},[n,x,d]);const y=[E,n,d];if(y.t=E,y.i18n=n,y.ready=d,d||!d&&!T)return y;throw new Promise(i=>{t.lng?F(n,t.lng,a,()=>i()):z(n,a,()=>i())})};export{Z as i,_ as u};
