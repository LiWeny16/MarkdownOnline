import React, { useState, useCallback, useMemo, useEffect } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  TextField,
  IconButton,
  Tooltip,
  Box
} from '@mui/material';
import {
  Edit as EditIcon,
  Check as CheckIcon,
  Close as CloseIcon,
  Add as AddIcon,
  Delete as DeleteIcon
} from '@mui/icons-material';
import { TableData } from '@Func/Parser/mdItPlugin/table';
import { getTableData, tableSyncManager } from '@App/text/tableEditor';
import { getTableMetadata } from '@App/text/tableEditor';

interface ReactTableProps {
  tableId?: string;
  tableData?: TableData;
}

interface EditingCell {
  rowIndex: number;
  colIndex: number;
  value: string;
}

const ReactTable: React.FC<ReactTableProps> = React.memo(({ tableId, tableData: propTableData }) => {
  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [data, setData] = useState<TableData>({ headers: [], rows: [] });
  const [editingCell, setEditingCell] = useState<EditingCell | null>(null);
  const [isEditMode, setIsEditMode] = useState(false);

  // ÈªòËÆ§Á§∫‰æãÊï∞ÊçÆÔºàÁî®‰∫éÂêéÂ§áÔºâ
  const defaultTableData: TableData = useMemo(() => ({
    headers: ['Name', 'Age', 'City', 'Email'],
    rows: [
      ['John Doe', '25', 'New York', 'john@example.com'],
      ['Jane Smith', '30', 'London', 'jane@example.com'],
      ['Bob Johnson', '35', 'Tokyo', 'bob@example.com'],
      ['Alice Brown', '28', 'Paris', 'alice@example.com']
    ]
  }), []);

  // üöÄ Êñ∞ÁöÑÂêåÊ≠•Êú∫Âà∂Ôºö‰ΩøÁî®TableSyncManagerËøõË°åÂèåÂêëÊï∞ÊçÆÁªëÂÆö
  const updateDataAndSync = useCallback((newData: TableData) => {
    // 1. Êõ¥Êñ∞Êú¨Âú∞Áä∂ÊÄÅ
    setData(newData);
    
    // 2. Â¶ÇÊûúÊúâtableIdÔºåÈÄöËøáÂêåÊ≠•ÁÆ°ÁêÜÂô®Ëß¶ÂèëMonacoÊõ¥Êñ∞
    if (tableId) {
      tableSyncManager.notifyTableDataChange(tableId, newData, 'react');
    }
  }, [tableId]);

  // Monaco ‚Üí React Êï∞ÊçÆÂêåÊ≠•ÁõëÂê¨Âô®
  useEffect(() => {
    if (!tableId) return;

    const handleMonacoDataChange = (newData: TableData) => {
      console.log(`ReactTableÊî∂Âà∞MonacoÊï∞ÊçÆÊõ¥Êñ∞ - tableId: ${tableId}`);
      const dataChanged = JSON.stringify(data) !== JSON.stringify(newData);
      if (dataChanged) {
        setData(newData);
      }
    };

    // Ê≥®ÂÜåÁõëÂê¨Âô®
    tableSyncManager.addTableListener(tableId, handleMonacoDataChange);

    return () => {
      // Ê∏ÖÁêÜÁõëÂê¨Âô®
      tableSyncManager.removeTableListener(tableId, handleMonacoDataChange);
    };
  }, [tableId, data]);

  // ÂàùÂßãÂåñÊï∞ÊçÆ
  useEffect(() => {
    let initialData: TableData;
    
    if (tableId) {
      // Â∞ùËØï‰ªéregistryËé∑ÂèñÁúüÂÆûË°®Ê†ºÊï∞ÊçÆ
      const registeredData = getTableData(tableId);
      initialData = registeredData || defaultTableData;
      console.log(`ReactTableÂàùÂßãÂåñ - tableId: ${tableId}, ÊâæÂà∞Êï∞ÊçÆ:`, !!registeredData, 'headers:', registeredData?.headers?.length || 0, 'rows:', registeredData?.rows?.length || 0);
    } else {
      // ‰ΩøÁî®props‰º†ÂÖ•ÁöÑÊï∞ÊçÆÊàñÈªòËÆ§Êï∞ÊçÆ
      initialData = propTableData || defaultTableData;
      console.log('ReactTableÂàùÂßãÂåñ - ‰ΩøÁî®propsÊàñÈªòËÆ§Êï∞ÊçÆ');
    }
    
    // Ê£ÄÊü•Êï∞ÊçÆÊòØÂê¶ÁúüÁöÑÂèëÁîü‰∫ÜÂèòÂåñÔºåÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑÈáçÊñ∞Ê∏≤Êüì
    const dataChanged = JSON.stringify(data) !== JSON.stringify(initialData);
    if (dataChanged) {
      console.log(`ReactTableÊï∞ÊçÆÂèòÂåñ - tableId: ${tableId}`, {
        oldData: { headers: data.headers.length, rows: data.rows.length },
        newData: { headers: initialData.headers.length, rows: initialData.rows.length }
      });
      setData(initialData);
    }
  }, [tableId, propTableData, defaultTableData]); // ÁßªÈô§data‰æùËµñÔºåÈÅøÂÖçÂæ™ÁéØÊõ¥Êñ∞

  // ÂºÄÂßãÁºñËæëÂçïÂÖÉÊ†º
  const startEdit = useCallback((rowIndex: number, colIndex: number) => {
    const isHeader = rowIndex === -1;
    const value = isHeader 
      ? data.headers[colIndex] || ''
      : data.rows[rowIndex]?.[colIndex] || '';
    
    setEditingCell({ rowIndex, colIndex, value });
  }, [data]);

  // Êèê‰∫§ÁºñËæë
  const commitEdit = useCallback(() => {
    if (!editingCell) return;

    const { rowIndex, colIndex, value } = editingCell;
    
    setData(prevData => {
      // Ê∑±Êã∑Ë¥ùÊï∞ÊçÆÔºåÈÅøÂÖçÁõ¥Êé•‰øÆÊîπ
      const newData = {
        headers: [...prevData.headers],
        rows: prevData.rows.map(row => [...row])
      };
      
      if (rowIndex === -1) {
        // ÁºñËæëË°®Â§¥
        newData.headers[colIndex] = value;
      } else {
        // ÁºñËæëÊï∞ÊçÆË°å
        if (!newData.rows[rowIndex]) {
          newData.rows[rowIndex] = new Array(newData.headers.length).fill('');
        }
        newData.rows[rowIndex][colIndex] = value;
      }
      
      // üöÄ ‰ΩøÁî®Êñ∞ÁöÑÂêåÊ≠•Êú∫Âà∂
      if (tableId) {
        setTimeout(() => {
          tableSyncManager.notifyTableDataChange(tableId, newData, 'react');
        }, 0);
      }
      
      return newData;
    });

    setEditingCell(null);
  }, [editingCell, tableId]);

  // ÂèñÊ∂àÁºñËæë
  const cancelEdit = useCallback(() => {
    setEditingCell(null);
  }, []);

  // Ê∑ªÂä†Ë°å
  const addRow = useCallback(() => {
    const newData = {
      headers: [...data.headers],
      rows: data.rows.map(row => [...row])
    };
    
    // Á°Æ‰øùÊñ∞Ë°åÁöÑÂàóÊï∞‰∏éÁé∞ÊúâË°®Â§¥Êï∞ÈáèÂÆåÂÖ®‰∏ÄËá¥
    const colCount = newData.headers.length;
    const newRow = new Array(colCount).fill('');
    newData.rows.push(newRow);
    
    // üöÄ ‰ΩøÁî®Êñ∞ÁöÑÂêåÊ≠•Êõ¥Êñ∞Êú∫Âà∂
    updateDataAndSync(newData);
  }, [data, updateDataAndSync]);

  // Âà†Èô§Ë°å
  const deleteRow = useCallback((rowIndex: number) => {
    const newData = {
      headers: [...data.headers],
      rows: data.rows.map(row => [...row])
    };
    newData.rows.splice(rowIndex, 1);
    
    // üöÄ ‰ΩøÁî®Êñ∞ÁöÑÂêåÊ≠•Êõ¥Êñ∞Êú∫Âà∂
    updateDataAndSync(newData);
  }, [data, updateDataAndSync]);

  // Ê∑ªÂä†Âàó
  const addColumn = useCallback(() => {
    const newData = {
      headers: [...data.headers],
      rows: data.rows.map(row => [...row])
    };
    
    // Ê∑ªÂä†Êñ∞ÁöÑË°®Â§¥
    newData.headers.push(`Col ${newData.headers.length + 1}`);
    
    // ‰∏∫ÊØè‰∏ÄË°åÈÉΩÊ∑ªÂä†‰∏Ä‰∏™Á©∫ÂçïÂÖÉÊ†ºÔºåÁ°Æ‰øùÊâÄÊúâË°åÈÉΩÊúâÁõ∏ÂêåÁöÑÂàóÊï∞
    newData.rows.forEach(row => {
      row.push('');
    });
    
    // üöÄ ‰ΩøÁî®Êñ∞ÁöÑÂêåÊ≠•Êõ¥Êñ∞Êú∫Âà∂
    updateDataAndSync(newData);
  }, [data, updateDataAndSync]);

  // Âà†Èô§Âàó
  const deleteColumn = useCallback((colIndex: number) => {
    if (data.headers.length <= 1) {
      // ‰∏çÂÖÅËÆ∏Âà†Èô§ÊúÄÂêé‰∏ÄÂàó
      return;
    }
    
    const newData = {
      headers: [...data.headers],
      rows: data.rows.map(row => [...row])
    };
    
    // Âà†Èô§Ë°®Â§¥‰∏≠ÁöÑÂàó
    newData.headers.splice(colIndex, 1);
    
    // Âà†Èô§ÊØèË°å‰∏≠ÂØπÂ∫îÁöÑÂàó
    newData.rows.forEach(row => {
      if (row.length > colIndex) {
        row.splice(colIndex, 1);
      }
    });
    
    // üöÄ ‰ΩøÁî®Êñ∞ÁöÑÂêåÊ≠•Êõ¥Êñ∞Êú∫Âà∂
    updateDataAndSync(newData);
  }, [data, updateDataAndSync]);

  // Ê∏≤ÊüìÁºñËæëÂô®
  const renderEditor = useCallback((currentValue: string) => (
    <TextField
      value={editingCell?.value || ''}
      onChange={(e) => setEditingCell(prev => 
        prev ? { ...prev, value: e.target.value } : null
      )}
      onKeyDown={(e) => {
        if (e.key === 'Enter') {
          commitEdit();
        } else if (e.key === 'Escape') {
          cancelEdit();
        }
      }}
      onBlur={commitEdit}
      autoFocus
      size="small"
      variant="outlined"
      sx={{ 
        minWidth: '100px',
        '& .MuiOutlinedInput-root': {
          fontSize: '0.875rem'
        }
      }}
    />
  ), [editingCell, commitEdit, cancelEdit]);

  // Ê∏≤ÊüìÂçïÂÖÉÊ†ºÂÜÖÂÆπÔºåÁ©∫Â≠óÁ¨¶‰∏≤ÊòæÁ§∫‰∏∫‰∏çÈó¥Êñ≠Á©∫Ê†º
  const renderCellContent = useCallback((
    value: string, 
    rowIndex: number, 
    colIndex: number, 
    isHeader: boolean = false
  ) => {
    const isEditing = editingCell?.rowIndex === rowIndex && editingCell?.colIndex === colIndex;
    
    if (isEditing) {
      return renderEditor(value);
    }

    // Á©∫Â≠óÁ¨¶‰∏≤ÊòæÁ§∫‰∏∫‰∏çÈó¥Êñ≠Á©∫Ê†º
    const displayValue = value === '' ? '\u00A0' : value;

    return (
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          minHeight: '32px',
          cursor: 'pointer',
          '&:hover': {
            backgroundColor: isHeader ? 'rgba(0,0,0,0.04)' : 'rgba(0,0,0,0.02)'
          }
        }}
        onDoubleClick={() => startEdit(rowIndex, colIndex)}
      >
        <span>{displayValue || (isHeader ? `Header ${colIndex + 1}` : '')}</span>
        {isEditMode && (
          <IconButton
            size="small"
            onClick={(e) => {
              e.stopPropagation();
              startEdit(rowIndex, colIndex);
            }}
            sx={{ opacity: 0.6, '&:hover': { opacity: 1 } }}
          >
            <EditIcon fontSize="inherit" />
          </IconButton>
        )}
      </Box>
    );
  }, [editingCell, renderEditor, startEdit, isEditMode]);

  if (!data || (!data.headers.length && !data.rows.length)) {
    return (
      <Paper sx={{ p: 2, textAlign: 'center', color: 'text.secondary' }}>
        Empty table - {tableId ? `Table ID: ${tableId}` : 'No data'}
      </Paper>
    );
  }

  return (
    <Paper elevation={0} sx={{ width: '100%', overflow: 'hidden' }} className="academic-table">
      {/* Â∑•ÂÖ∑Ê†è */}
      <Box sx={{ p: 1, display: 'flex', gap: 1, borderBottom: '1px solid #e0e0e0' }} className="react-table-toolbar">
        <Tooltip title={isEditMode ? "Exit Edit Mode" : "Enter Edit Mode"}>
          <IconButton 
            size="small" 
            onClick={() => setIsEditMode(!isEditMode)}
            color={isEditMode ? "primary" : "default"}
          >
            <EditIcon />
          </IconButton>
        </Tooltip>
        
        {isEditMode && (
          <>
            <Tooltip title="Add Row">
              <IconButton size="small" onClick={addRow}>
                <AddIcon />
              </IconButton>
            </Tooltip>
            
            <Tooltip title="Add Column">
              <IconButton size="small" onClick={addColumn}>
                <AddIcon sx={{ transform: 'rotate(90deg)' }} />
              </IconButton>
            </Tooltip>
          </>
        )}
        
        {tableId && (
          <Box sx={{ ml: 'auto', fontSize: '0.75rem', color: 'text.secondary', display: 'flex', alignItems: 'center' }}>
            Table ID: {tableId}
          </Box>
        )}
      </Box>

      {/* Ë°®Ê†º */}
      <TableContainer sx={{ maxHeight: 440 }}>
        <Table size="small" stickyHeader>
          <TableHead>
            <TableRow sx={{ 
              backgroundColor: '#f5f5f5',
              '& .MuiTableCell-head': {
                fontWeight: 600,
                borderBottom: '2px solid #e0e0e0',
                color: '#333',
                position: 'sticky',
                top: 0,
                backgroundColor: '#f5f5f5',
                zIndex: 10
              }
            }}>
              {data.headers.map((header, colIndex) => (
                <TableCell key={colIndex} sx={{ minWidth: 120 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                    {renderCellContent(header, -1, colIndex, true)}
                    {isEditMode && data.headers.length > 1 && (
                      <Tooltip title="Delete Column">
                        <IconButton
                          size="small"
                          onClick={() => deleteColumn(colIndex)}
                          color="error"
                          sx={{ opacity: 0.6, '&:hover': { opacity: 1 }, ml: 1 }}
                        >
                          <DeleteIcon fontSize="inherit" />
                        </IconButton>
                      </Tooltip>
                    )}
                  </Box>
                </TableCell>
              ))}
              {isEditMode && (
                <TableCell sx={{ width: 50 }}>Actions</TableCell>
              )}
            </TableRow>
          </TableHead>
          
          <TableBody>
            {data.rows.map((row, rowIndex) => (
              <TableRow 
                key={rowIndex}
                sx={{ 
                  '&:nth-of-type(even)': { 
                    backgroundColor: '#fafafa' 
                  },
                  '&:hover': {
                    backgroundColor: '#f0f0f0'
                  }
                }}
              >
                {row.map((cell, colIndex) => (
                  <TableCell key={colIndex} sx={{ minWidth: 120 }}>
                    {renderCellContent(cell, rowIndex, colIndex)}
                  </TableCell>
                ))}
                
                {isEditMode && (
                  <TableCell>
                    <Tooltip title="Delete Row">
                      <IconButton
                        size="small"
                        onClick={() => deleteRow(rowIndex)}
                        color="error"
                        sx={{ opacity: 0.6, '&:hover': { opacity: 1 } }}
                      >
                        <DeleteIcon fontSize="inherit" />
                      </IconButton>
                    </Tooltip>
                  </TableCell>
                )}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Paper>
  );
}, (prevProps, nextProps) => {
  // Ëá™ÂÆö‰πâÊØîËæÉÂáΩÊï∞Ôºå‰ºòÂåñÊÄßËÉΩ
  if (prevProps.tableId !== nextProps.tableId) return false;
  return JSON.stringify(prevProps.tableData) === JSON.stringify(nextProps.tableData);
});

// Ë°®Ê†ºÁÆ°ÁêÜÂô® - Êô∫ËÉΩÈÅøÂÖçÈó™ÁÉÅÁâàÊú¨
class TableManager {
  private static instance: TableManager;
  private mountedRoots = new Map<string, any>(); // ‰ΩøÁî®tableId‰Ωú‰∏∫key
  private lastTableStates = new Map<string, string>(); // ‰øùÂ≠òÊØè‰∏™Ë°®Ê†ºÁöÑÊúÄÂêéÁä∂ÊÄÅhash

  static getInstance(): TableManager {
    if (!TableManager.instance) {
      TableManager.instance = new TableManager();
    }
    return TableManager.instance;
  }

  // Êô∫ËÉΩÊåÇËΩΩÔºöÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑDOMÈáçÂª∫
  mountTables() {
    console.log('=== TableManager.mountTables() ÂºÄÂßã ===');
    
    // Êü•ÊâæÂΩìÂâçÊâÄÊúâË°®Ê†ºÂç†‰ΩçÁ¨¶
    const placeholders = document.querySelectorAll('[data-react-table]') as NodeListOf<HTMLElement>;
    const currentTableIds = new Set<string>();
    
    console.log(`ÂèëÁé∞ ${placeholders.length} ‰∏™Ë°®Ê†ºÂç†‰ΩçÁ¨¶`);
    
    // Â§ÑÁêÜÊØè‰∏™Âç†‰ΩçÁ¨¶
    placeholders.forEach((placeholder, index) => {
      const tableId = placeholder.getAttribute('data-table-id');
      const domTableHash = placeholder.getAttribute('data-table-hash'); // DOM‰∏≠ÁöÑÂìàÂ∏å
      
      if (!tableId) {
        console.warn(`Ë°®Ê†ºÂç†‰ΩçÁ¨¶ ${index} Áº∫Â∞ë data-table-id`);
        return;
      }
      
      currentTableIds.add(tableId);
      
      // ‰ªéË°®Ê†ºÊ≥®ÂÜåË°®Ëé∑ÂèñÂΩìÂâçÁöÑÁúüÂÆûÂìàÂ∏å
      const registryMetadata = getTableMetadata(tableId);
      const currentTableHash = registryMetadata?.tableHash || null;
      
      const lastHash = this.lastTableStates.get(tableId);
      const existingRoot = this.mountedRoots.get(tableId);
      const hasContent = placeholder.children.length > 0;
      
      console.log(`Ë°®Ê†º ${tableId}:`, {
        domHash: domTableHash,
        registryHash: currentTableHash,
        lastHash: lastHash,
        hasExistingRoot: !!existingRoot,
        hasContent: hasContent,
        needsUpdate: currentTableHash !== lastHash || !hasContent
      });
      
      // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞Ê≥®ÂÜåË°®Êï∞ÊçÆÔºåË∑≥ËøáÊ≠§Ë°®Ê†º
      if (!currentTableHash) {
        console.warn(`Ë°®Ê†º ${tableId} Âú®Ê≥®ÂÜåË°®‰∏≠Êú™ÊâæÂà∞ÔºåË∑≥ËøáÂ§ÑÁêÜ`);
        return;
      }
      
      // ÂÖ≥ÈîÆ‰ºòÂåñÔºö‰ΩøÁî®Ê≥®ÂÜåË°®‰∏≠ÁöÑÂìàÂ∏åËøõË°åÊØîËæÉ
      if (existingRoot && currentTableHash === lastHash && hasContent) {
        console.log(`Ë°®Ê†º ${tableId} ÂÜÖÂÆπÊú™Âèò‰∏îDOMÂÆåÊï¥ÔºåË∑≥ËøáÊõ¥Êñ∞`);
        return;
      }
      
      // Â¶ÇÊûúÊúâÊ†πËäÇÁÇπ‰ΩÜÂÜÖÂÆπË¢´Ê∏ÖÁ©∫‰∫ÜÔºåÊàñËÄÖÂìàÂ∏åÂèòÂåñ‰∫ÜÔºåÈúÄË¶ÅÈáçÊñ∞Ê∏≤Êüì
      if (existingRoot && (!hasContent || currentTableHash !== lastHash)) {
        console.log(`Ë°®Ê†º ${tableId} ÈúÄË¶ÅÊõ¥Êñ∞ - DOMÊ∏ÖÁ©∫: ${!hasContent}, ÂìàÂ∏åÂèòÂåñ: ${currentTableHash !== lastHash}`);
        this.updateTable(tableId, currentTableHash);
        return;
      }
      
      // Â¶ÇÊûúÈúÄË¶ÅÂàõÂª∫Êñ∞ÁöÑÊ†πËäÇÁÇπ
      if (!existingRoot) {
        console.log(`‰∏∫Ë°®Ê†º ${tableId} ÂàõÂª∫Êñ∞ÁöÑ React Ê†πËäÇÁÇπ`);
        this.createTableRoot(placeholder, tableId, currentTableHash);
      }
    });
    
    // Ê∏ÖÁêÜ‰∏çÂÜçÂ≠òÂú®ÁöÑË°®Ê†º
    this.cleanupUnusedRoots(currentTableIds);
    
    console.log('=== TableManager.mountTables() ÂÆåÊàê ===');
  }

  // ÂàõÂª∫Êñ∞ÁöÑË°®Ê†ºÊ†πËäÇÁÇπ
  private createTableRoot(placeholder: HTMLElement, tableId: string, tableHash: string | null) {
    try {
      // ÈáçÁΩÆÂç†‰ΩçÁ¨¶Ê†∑Âºè
      placeholder.style.border = 'none';
      placeholder.style.background = 'transparent';
      placeholder.style.minHeight = 'auto';
      placeholder.style.padding = '0';
      placeholder.style.margin = '16px 0';
      
      // Âä®ÊÄÅÂØºÂÖ• react-dom/client
      import('react-dom/client').then(({ createRoot }) => {
        // ÂÜçÊ¨°Ê£ÄÊü•Âç†‰ΩçÁ¨¶ÊòØÂê¶‰ªçÁÑ∂Â≠òÂú®
        if (!document.contains(placeholder)) {
          console.warn(`Ë°®Ê†º ${tableId} ÁöÑÂç†‰ΩçÁ¨¶Â∑≤Ë¢´ÁßªÈô§`);
          return;
        }
        
        const root = createRoot(placeholder);
        root.render(React.createElement(ReactTable, { tableId }));
        
        // ‰øùÂ≠òÊ†πËäÇÁÇπÂíåÁä∂ÊÄÅ
        this.mountedRoots.set(tableId, root);
        if (tableHash) {
          this.lastTableStates.set(tableId, tableHash);
        }
        
        console.log(`ÊàêÂäüÊåÇËΩΩË°®Ê†º ${tableId}`);
      }).catch(e => {
        console.error(`ÂàõÂª∫Ë°®Ê†º ${tableId} Ê†πËäÇÁÇπÂ§±Ë¥•:`, e);
      });
    } catch (e) {
      console.error(`‰∏∫Ë°®Ê†º ${tableId} ÂàõÂª∫Ê†πËäÇÁÇπÊó∂ÂèëÁîüÈîôËØØ:`, e);
    }
  }

  // Êõ¥Êñ∞Áé∞ÊúâË°®Ê†ºÔºà‰∏çÈáçÂª∫Ê†πËäÇÁÇπÔºâ
  private updateTable(tableId: string, tableHash: string | null) {
    const root = this.mountedRoots.get(tableId);
    if (root && tableHash) {
      try {
        // ‰ΩøÁî®tableHash‰Ωú‰∏∫keyÔºåÁ°Æ‰øùReactËÉΩÊ£ÄÊµãÂà∞ÂèòÂåñ
        root.render(React.createElement(ReactTable, { 
          tableId,
          key: `${tableId}-${tableHash}` // ‰ΩøÁî®hashÁ°Æ‰øùpropsÂèòÂåñÊó∂ÈáçÊñ∞Ê∏≤Êüì
        }));
        this.lastTableStates.set(tableId, tableHash);
        console.log(`ÊàêÂäüÊõ¥Êñ∞Ë°®Ê†º ${tableId}, Êñ∞hash: ${tableHash}`);
      } catch (e) {
        console.error(`Êõ¥Êñ∞Ë°®Ê†º ${tableId} Â§±Ë¥•:`, e);
      }
    }
  }

  // Ê∏ÖÁêÜ‰∏çÂÜçÂ≠òÂú®ÁöÑË°®Ê†ºÊ†πËäÇÁÇπ
  private cleanupUnusedRoots(currentTableIds: Set<string>) {
    const toDelete: string[] = [];
    
    this.mountedRoots.forEach((root, tableId) => {
      if (!currentTableIds.has(tableId)) {
        console.log(`Ê∏ÖÁêÜ‰∏çÂÜçÂ≠òÂú®ÁöÑË°®Ê†º ${tableId}`);
        try {
          root.unmount();
          toDelete.push(tableId);
        } catch (e) {
          console.warn(`Âç∏ËΩΩË°®Ê†º ${tableId} Â§±Ë¥•:`, e);
        }
      }
    });
    
    // ‰ªéÊò†Â∞Ñ‰∏≠Âà†Èô§
    toDelete.forEach(tableId => {
      this.mountedRoots.delete(tableId);
      this.lastTableStates.delete(tableId);
      // üöÄ Ê∏ÖÁêÜÂêåÊ≠•ÁõëÂê¨Âô®
      tableSyncManager.clearTableListeners(tableId);
    });
    
    if (toDelete.length > 0) {
      console.log(`Ê∏ÖÁêÜ‰∫Ü ${toDelete.length} ‰∏™Â∫üÂºÉË°®Ê†º`);
    }
  }

  // Âº∫Âà∂ÈáçÊñ∞ÊåÇËΩΩÊâÄÊúâË°®Ê†ºÔºàÁî®‰∫éÁâπÊÆäÊÉÖÂÜµÔºâ
  forceRemountAllTables() {
    console.log('Âº∫Âà∂ÈáçÊñ∞ÊåÇËΩΩÊâÄÊúâË°®Ê†º');
    this.unmountAllTables();
    this.mountTables();
  }

  // Âç∏ËΩΩÊâÄÊúâË°®Ê†º
  unmountAllTables() {
    console.log('Âç∏ËΩΩÊâÄÊúâË°®Ê†ºÊ†πËäÇÁÇπ');
    this.mountedRoots.forEach((root, tableId) => {
      try {
        root.unmount();
        // üöÄ Ê∏ÖÁêÜÂêåÊ≠•ÁõëÂê¨Âô®
        tableSyncManager.clearTableListeners(tableId);
      } catch (e) {
        console.warn(`Âç∏ËΩΩË°®Ê†º ${tableId} Â§±Ë¥•:`, e);
      }
    });
    this.mountedRoots.clear();
    this.lastTableStates.clear();
    // üöÄ Ê∏ÖÁêÜÊâÄÊúâÂêåÊ≠•ÁõëÂê¨Âô®
    tableSyncManager.clearAllListeners();
  }

  // Ëé∑ÂèñË∞ÉËØï‰ø°ÊÅØ
  getDebugInfo() {
    return {
      mountedRootsCount: this.mountedRoots.size,
      tableStatesCount: this.lastTableStates.size,
      mountedTableIds: Array.from(this.mountedRoots.keys()),
      tableStates: Object.fromEntries(this.lastTableStates),
      syncListenersCount: (tableSyncManager as any).syncListeners?.size || 0
    };
  }
}

export { ReactTable, TableManager };
export default ReactTable;

// ÂºÄÂèëËÄÖË∞ÉËØïÂ∑•ÂÖ∑Ôºà‰ªÖÂú®ÂºÄÂèëÁéØÂ¢É‰∏≠Ê∑ªÂä†Âà∞ÂÖ®Â±ÄÔºâ
if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
  (window as any).TableManagerDebug = {
    getInstance: () => TableManager.getInstance(),
    getDebugInfo: () => TableManager.getInstance().getDebugInfo(),
    forceRemount: () => TableManager.getInstance().forceRemountAllTables(),
    unmountAll: () => TableManager.getInstance().unmountAllTables(),
    syncManager: tableSyncManager
  };
}